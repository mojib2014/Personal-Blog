{"ast":null,"code":"'use strict';\n\nvar Parser = require('parse5/lib/parser');\n\nvar pos = require('unist-util-position');\n\nvar visit = require('unist-util-visit');\n\nvar fromParse5 = require('hast-util-from-parse5');\n\nvar toParse5 = require('hast-util-to-parse5');\n\nvar voids = require('html-void-elements');\n\nvar ns = require('web-namespaces');\n\nvar zwitch = require('zwitch');\n\nvar xtend = require('xtend');\n\nmodule.exports = wrap;\nvar inTemplateMode = 'IN_TEMPLATE_MODE';\nvar dataState = 'DATA_STATE';\nvar characterToken = 'CHARACTER_TOKEN';\nvar startTagToken = 'START_TAG_TOKEN';\nvar endTagToken = 'END_TAG_TOKEN';\nvar commentToken = 'COMMENT_TOKEN';\nvar doctypeToken = 'DOCTYPE_TOKEN';\nvar parseOptions = {\n  sourceCodeLocationInfo: true,\n  scriptingEnabled: false\n};\n\nfunction wrap(tree, file, options) {\n  var parser = new Parser(parseOptions);\n  var one = zwitch('type', {\n    handlers: {\n      root: root,\n      element: element,\n      text: text,\n      comment: comment,\n      doctype: doctype,\n      raw: raw\n    },\n    unknown: unknown\n  });\n  var stitches;\n  var tokenizer;\n  var preprocessor;\n  var posTracker;\n  var locationTracker;\n  var result;\n  var index;\n\n  if (file && !('contents' in file)) {\n    options = file;\n    file = undefined;\n  }\n\n  if (options && options.passThrough) {\n    index = -1;\n\n    while (++index < options.passThrough.length) {\n      one.handlers[options.passThrough[index]] = stitch;\n    }\n  }\n\n  result = fromParse5(documentMode(tree) ? document() : fragment(), file);\n\n  if (stitches) {\n    visit(result, 'comment', mend);\n  } // Unpack if possible and when not given a `root`.\n\n\n  if (tree.type !== 'root' && result.children.length === 1) {\n    return result.children[0];\n  }\n\n  return result;\n\n  function mend(node, index, parent) {\n    if (node.value.stitch) {\n      parent.children[index] = node.value.stitch;\n      return index;\n    }\n  }\n\n  function fragment() {\n    var context = {\n      nodeName: 'template',\n      tagName: 'template',\n      attrs: [],\n      namespaceURI: ns.html,\n      childNodes: []\n    };\n    var mock = {\n      nodeName: 'documentmock',\n      tagName: 'documentmock',\n      attrs: [],\n      namespaceURI: ns.html,\n      childNodes: []\n    };\n    var doc = {\n      nodeName: '#document-fragment',\n      childNodes: []\n    };\n\n    parser._bootstrap(mock, context);\n\n    parser._pushTmplInsertionMode(inTemplateMode);\n\n    parser._initTokenizerForFragmentParsing();\n\n    parser._insertFakeRootElement();\n\n    parser._resetInsertionMode();\n\n    parser._findFormInFragmentContext();\n\n    tokenizer = parser.tokenizer;\n    preprocessor = tokenizer.preprocessor;\n    locationTracker = tokenizer.__mixins[0];\n    posTracker = locationTracker.posTracker;\n    one(tree);\n\n    parser._adoptNodes(mock.childNodes[0], doc);\n\n    return doc;\n  }\n\n  function document() {\n    var doc = parser.treeAdapter.createDocument();\n\n    parser._bootstrap(doc, null);\n\n    tokenizer = parser.tokenizer;\n    preprocessor = tokenizer.preprocessor;\n    locationTracker = tokenizer.__mixins[0];\n    posTracker = locationTracker.posTracker;\n    one(tree);\n    return doc;\n  }\n\n  function all(nodes) {\n    var index = -1;\n    /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n\n    if (nodes) {\n      while (++index < nodes.length) {\n        one(nodes[index]);\n      }\n    }\n  }\n\n  function root(node) {\n    all(node.children);\n  }\n\n  function element(node) {\n    resetTokenizer();\n\n    parser._processToken(startTag(node), ns.html);\n\n    all(node.children);\n\n    if (voids.indexOf(node.tagName) < 0) {\n      resetTokenizer();\n\n      parser._processToken(endTag(node));\n    }\n  }\n\n  function text(node) {\n    resetTokenizer();\n\n    parser._processToken({\n      type: characterToken,\n      chars: node.value,\n      location: createParse5Location(node)\n    });\n  }\n\n  function doctype(node) {\n    var p5 = toParse5(node);\n    resetTokenizer();\n\n    parser._processToken({\n      type: doctypeToken,\n      name: p5.name,\n      forceQuirks: false,\n      publicId: p5.publicId,\n      systemId: p5.systemId,\n      location: createParse5Location(node)\n    });\n  }\n\n  function comment(node) {\n    resetTokenizer();\n\n    parser._processToken({\n      type: commentToken,\n      data: node.value,\n      location: createParse5Location(node)\n    });\n  }\n\n  function raw(node) {\n    var start = pos.start(node);\n    var line = start.line || 1;\n    var column = start.column || 1;\n    var offset = start.offset || 0;\n    var token; // Reset preprocessor:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js>.\n\n    preprocessor.html = null;\n    preprocessor.pos = -1;\n    preprocessor.lastGapPos = -1;\n    preprocessor.lastCharPos = -1;\n    preprocessor.gapStack = [];\n    preprocessor.skipNextNewLine = false;\n    preprocessor.lastChunkWritten = false;\n    preprocessor.endOfChunkHit = false; // Reset preprocessor mixin:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n\n    posTracker.isEol = false;\n    posTracker.lineStartPos = -column + 1; // Looks weird, but ensures we get correct positional info.\n\n    posTracker.droppedBufferSize = offset;\n    posTracker.offset = 0;\n    posTracker.col = 1;\n    posTracker.line = line; // Reset location tracker:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n\n    locationTracker.currentAttrLocation = null;\n    locationTracker.ctLoc = createParse5Location(node); // See the code for `parse` and `parseFragment`:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n\n    tokenizer.write(node.value);\n\n    parser._runParsingLoop(null); // Process final characters if theyâ€™re still there after hibernating.\n    // Similar to:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n\n\n    token = tokenizer.currentCharacterToken;\n\n    if (token) {\n      token.location.endLine = posTracker.line;\n      token.location.endCol = posTracker.col + 1;\n      token.location.endOffset = posTracker.offset + 1;\n\n      parser._processToken(token);\n    }\n  }\n\n  function stitch(node) {\n    var clone = Object.assign({}, node);\n    stitches = true; // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n    // passed through node).\n\n    if (node.children) {\n      clone.children = wrap({\n        type: 'root',\n        children: node.children\n      }, file, options).children;\n    } // Hack: `value` is supposed to be a string, but as none of the tools\n    // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n    // through.\n\n\n    comment({\n      value: {\n        stitch: clone\n      }\n    });\n  }\n\n  function resetTokenizer() {\n    // Reset tokenizer:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n    // Especially putting it back in the `data` state is useful: some elements,\n    // like textareas and iframes, change the state.\n    // See GH-7.\n    // But also if broken HTML is in `raw`, and then a correct element is given.\n    // See GH-11.\n    tokenizer.tokenQueue = [];\n    tokenizer.state = dataState;\n    tokenizer.returnState = '';\n    tokenizer.charRefCode = -1;\n    tokenizer.tempBuff = [];\n    tokenizer.lastStartTagName = '';\n    tokenizer.consumedAfterSnapshot = -1;\n    tokenizer.active = false;\n    tokenizer.currentCharacterToken = null;\n    tokenizer.currentToken = null;\n    tokenizer.currentAttr = null;\n  }\n}\n\nfunction startTag(node) {\n  var location = createParse5Location(node);\n  location.startTag = xtend(location);\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location: location\n  };\n}\n\nfunction attributes(node) {\n  return toParse5({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties\n  }).attrs;\n}\n\nfunction endTag(node) {\n  var location = createParse5Location(node);\n  location.endTag = xtend(location);\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location: location\n  };\n}\n\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node');\n}\n\nfunction documentMode(node) {\n  var head = node.type === 'root' ? node.children[0] : node;\n  return head && (head.type === 'doctype' || head.tagName === 'html');\n}\n\nfunction createParse5Location(node) {\n  var start = pos.start(node);\n  var end = pos.end(node);\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  };\n}","map":{"version":3,"sources":["/Users/mojib2014/Desktop/projects/node_projects/blog/client/node_modules/hast-util-raw/index.js"],"names":["Parser","require","pos","visit","fromParse5","toParse5","voids","ns","zwitch","xtend","module","exports","wrap","inTemplateMode","dataState","characterToken","startTagToken","endTagToken","commentToken","doctypeToken","parseOptions","sourceCodeLocationInfo","scriptingEnabled","tree","file","options","parser","one","handlers","root","element","text","comment","doctype","raw","unknown","stitches","tokenizer","preprocessor","posTracker","locationTracker","result","index","undefined","passThrough","length","stitch","documentMode","document","fragment","mend","type","children","node","parent","value","context","nodeName","tagName","attrs","namespaceURI","html","childNodes","mock","doc","_bootstrap","_pushTmplInsertionMode","_initTokenizerForFragmentParsing","_insertFakeRootElement","_resetInsertionMode","_findFormInFragmentContext","__mixins","_adoptNodes","treeAdapter","createDocument","all","nodes","resetTokenizer","_processToken","startTag","indexOf","endTag","chars","location","createParse5Location","p5","name","forceQuirks","publicId","systemId","data","start","line","column","offset","token","lastGapPos","lastCharPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","isEol","lineStartPos","droppedBufferSize","col","currentAttrLocation","ctLoc","write","_runParsingLoop","currentCharacterToken","endLine","endCol","endOffset","clone","Object","assign","tokenQueue","state","returnState","charRefCode","tempBuff","lastStartTagName","consumedAfterSnapshot","active","currentToken","currentAttr","selfClosing","attributes","properties","Error","head","end","startLine","startCol","startOffset"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,mBAAD,CAApB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,qBAAD,CAAjB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,kBAAD,CAAnB;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAC,uBAAD,CAAxB;;AACA,IAAII,QAAQ,GAAGJ,OAAO,CAAC,qBAAD,CAAtB;;AACA,IAAIK,KAAK,GAAGL,OAAO,CAAC,oBAAD,CAAnB;;AACA,IAAIM,EAAE,GAAGN,OAAO,CAAC,gBAAD,CAAhB;;AACA,IAAIO,MAAM,GAAGP,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIQ,KAAK,GAAGR,OAAO,CAAC,OAAD,CAAnB;;AAEAS,MAAM,CAACC,OAAP,GAAiBC,IAAjB;AAEA,IAAIC,cAAc,GAAG,kBAArB;AACA,IAAIC,SAAS,GAAG,YAAhB;AACA,IAAIC,cAAc,GAAG,iBAArB;AACA,IAAIC,aAAa,GAAG,iBAApB;AACA,IAAIC,WAAW,GAAG,eAAlB;AACA,IAAIC,YAAY,GAAG,eAAnB;AACA,IAAIC,YAAY,GAAG,eAAnB;AAEA,IAAIC,YAAY,GAAG;AAACC,EAAAA,sBAAsB,EAAE,IAAzB;AAA+BC,EAAAA,gBAAgB,EAAE;AAAjD,CAAnB;;AAEA,SAASV,IAAT,CAAcW,IAAd,EAAoBC,IAApB,EAA0BC,OAA1B,EAAmC;AACjC,MAAIC,MAAM,GAAG,IAAI1B,MAAJ,CAAWoB,YAAX,CAAb;AACA,MAAIO,GAAG,GAAGnB,MAAM,CAAC,MAAD,EAAS;AACvBoB,IAAAA,QAAQ,EAAE;AACRC,MAAAA,IAAI,EAAEA,IADE;AAERC,MAAAA,OAAO,EAAEA,OAFD;AAGRC,MAAAA,IAAI,EAAEA,IAHE;AAIRC,MAAAA,OAAO,EAAEA,OAJD;AAKRC,MAAAA,OAAO,EAAEA,OALD;AAMRC,MAAAA,GAAG,EAAEA;AANG,KADa;AASvBC,IAAAA,OAAO,EAAEA;AATc,GAAT,CAAhB;AAWA,MAAIC,QAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,YAAJ;AACA,MAAIC,UAAJ;AACA,MAAIC,eAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,KAAJ;;AAEA,MAAIlB,IAAI,IAAI,EAAE,cAAcA,IAAhB,CAAZ,EAAmC;AACjCC,IAAAA,OAAO,GAAGD,IAAV;AACAA,IAAAA,IAAI,GAAGmB,SAAP;AACD;;AAED,MAAIlB,OAAO,IAAIA,OAAO,CAACmB,WAAvB,EAAoC;AAClCF,IAAAA,KAAK,GAAG,CAAC,CAAT;;AAEA,WAAO,EAAEA,KAAF,GAAUjB,OAAO,CAACmB,WAAR,CAAoBC,MAArC,EAA6C;AAC3ClB,MAAAA,GAAG,CAACC,QAAJ,CAAaH,OAAO,CAACmB,WAAR,CAAoBF,KAApB,CAAb,IAA2CI,MAA3C;AACD;AACF;;AAEDL,EAAAA,MAAM,GAAGrC,UAAU,CAAC2C,YAAY,CAACxB,IAAD,CAAZ,GAAqByB,QAAQ,EAA7B,GAAkCC,QAAQ,EAA3C,EAA+CzB,IAA/C,CAAnB;;AAEA,MAAIY,QAAJ,EAAc;AACZjC,IAAAA,KAAK,CAACsC,MAAD,EAAS,SAAT,EAAoBS,IAApB,CAAL;AACD,GAtCgC,CAwCjC;;;AACA,MAAI3B,IAAI,CAAC4B,IAAL,KAAc,MAAd,IAAwBV,MAAM,CAACW,QAAP,CAAgBP,MAAhB,KAA2B,CAAvD,EAA0D;AACxD,WAAOJ,MAAM,CAACW,QAAP,CAAgB,CAAhB,CAAP;AACD;;AAED,SAAOX,MAAP;;AAEA,WAASS,IAAT,CAAcG,IAAd,EAAoBX,KAApB,EAA2BY,MAA3B,EAAmC;AACjC,QAAID,IAAI,CAACE,KAAL,CAAWT,MAAf,EAAuB;AACrBQ,MAAAA,MAAM,CAACF,QAAP,CAAgBV,KAAhB,IAAyBW,IAAI,CAACE,KAAL,CAAWT,MAApC;AACA,aAAOJ,KAAP;AACD;AACF;;AAED,WAASO,QAAT,GAAoB;AAClB,QAAIO,OAAO,GAAG;AACZC,MAAAA,QAAQ,EAAE,UADE;AAEZC,MAAAA,OAAO,EAAE,UAFG;AAGZC,MAAAA,KAAK,EAAE,EAHK;AAIZC,MAAAA,YAAY,EAAErD,EAAE,CAACsD,IAJL;AAKZC,MAAAA,UAAU,EAAE;AALA,KAAd;AAOA,QAAIC,IAAI,GAAG;AACTN,MAAAA,QAAQ,EAAE,cADD;AAETC,MAAAA,OAAO,EAAE,cAFA;AAGTC,MAAAA,KAAK,EAAE,EAHE;AAITC,MAAAA,YAAY,EAAErD,EAAE,CAACsD,IAJR;AAKTC,MAAAA,UAAU,EAAE;AALH,KAAX;AAOA,QAAIE,GAAG,GAAG;AAACP,MAAAA,QAAQ,EAAE,oBAAX;AAAiCK,MAAAA,UAAU,EAAE;AAA7C,KAAV;;AAEApC,IAAAA,MAAM,CAACuC,UAAP,CAAkBF,IAAlB,EAAwBP,OAAxB;;AACA9B,IAAAA,MAAM,CAACwC,sBAAP,CAA8BrD,cAA9B;;AACAa,IAAAA,MAAM,CAACyC,gCAAP;;AACAzC,IAAAA,MAAM,CAAC0C,sBAAP;;AACA1C,IAAAA,MAAM,CAAC2C,mBAAP;;AACA3C,IAAAA,MAAM,CAAC4C,0BAAP;;AAEAjC,IAAAA,SAAS,GAAGX,MAAM,CAACW,SAAnB;AACAC,IAAAA,YAAY,GAAGD,SAAS,CAACC,YAAzB;AACAE,IAAAA,eAAe,GAAGH,SAAS,CAACkC,QAAV,CAAmB,CAAnB,CAAlB;AACAhC,IAAAA,UAAU,GAAGC,eAAe,CAACD,UAA7B;AAEAZ,IAAAA,GAAG,CAACJ,IAAD,CAAH;;AAEAG,IAAAA,MAAM,CAAC8C,WAAP,CAAmBT,IAAI,CAACD,UAAL,CAAgB,CAAhB,CAAnB,EAAuCE,GAAvC;;AAEA,WAAOA,GAAP;AACD;;AAED,WAAShB,QAAT,GAAoB;AAClB,QAAIgB,GAAG,GAAGtC,MAAM,CAAC+C,WAAP,CAAmBC,cAAnB,EAAV;;AAEAhD,IAAAA,MAAM,CAACuC,UAAP,CAAkBD,GAAlB,EAAuB,IAAvB;;AACA3B,IAAAA,SAAS,GAAGX,MAAM,CAACW,SAAnB;AACAC,IAAAA,YAAY,GAAGD,SAAS,CAACC,YAAzB;AACAE,IAAAA,eAAe,GAAGH,SAAS,CAACkC,QAAV,CAAmB,CAAnB,CAAlB;AACAhC,IAAAA,UAAU,GAAGC,eAAe,CAACD,UAA7B;AAEAZ,IAAAA,GAAG,CAACJ,IAAD,CAAH;AAEA,WAAOyC,GAAP;AACD;;AAED,WAASW,GAAT,CAAaC,KAAb,EAAoB;AAClB,QAAIlC,KAAK,GAAG,CAAC,CAAb;AAEA;;AACA,QAAIkC,KAAJ,EAAW;AACT,aAAO,EAAElC,KAAF,GAAUkC,KAAK,CAAC/B,MAAvB,EAA+B;AAC7BlB,QAAAA,GAAG,CAACiD,KAAK,CAAClC,KAAD,CAAN,CAAH;AACD;AACF;AACF;;AAED,WAASb,IAAT,CAAcwB,IAAd,EAAoB;AAClBsB,IAAAA,GAAG,CAACtB,IAAI,CAACD,QAAN,CAAH;AACD;;AAED,WAAStB,OAAT,CAAiBuB,IAAjB,EAAuB;AACrBwB,IAAAA,cAAc;;AACdnD,IAAAA,MAAM,CAACoD,aAAP,CAAqBC,QAAQ,CAAC1B,IAAD,CAA7B,EAAqC9C,EAAE,CAACsD,IAAxC;;AAEAc,IAAAA,GAAG,CAACtB,IAAI,CAACD,QAAN,CAAH;;AAEA,QAAI9C,KAAK,CAAC0E,OAAN,CAAc3B,IAAI,CAACK,OAAnB,IAA8B,CAAlC,EAAqC;AACnCmB,MAAAA,cAAc;;AACdnD,MAAAA,MAAM,CAACoD,aAAP,CAAqBG,MAAM,CAAC5B,IAAD,CAA3B;AACD;AACF;;AAED,WAAStB,IAAT,CAAcsB,IAAd,EAAoB;AAClBwB,IAAAA,cAAc;;AACdnD,IAAAA,MAAM,CAACoD,aAAP,CAAqB;AACnB3B,MAAAA,IAAI,EAAEpC,cADa;AAEnBmE,MAAAA,KAAK,EAAE7B,IAAI,CAACE,KAFO;AAGnB4B,MAAAA,QAAQ,EAAEC,oBAAoB,CAAC/B,IAAD;AAHX,KAArB;AAKD;;AAED,WAASpB,OAAT,CAAiBoB,IAAjB,EAAuB;AACrB,QAAIgC,EAAE,GAAGhF,QAAQ,CAACgD,IAAD,CAAjB;AACAwB,IAAAA,cAAc;;AACdnD,IAAAA,MAAM,CAACoD,aAAP,CAAqB;AACnB3B,MAAAA,IAAI,EAAEhC,YADa;AAEnBmE,MAAAA,IAAI,EAAED,EAAE,CAACC,IAFU;AAGnBC,MAAAA,WAAW,EAAE,KAHM;AAInBC,MAAAA,QAAQ,EAAEH,EAAE,CAACG,QAJM;AAKnBC,MAAAA,QAAQ,EAAEJ,EAAE,CAACI,QALM;AAMnBN,MAAAA,QAAQ,EAAEC,oBAAoB,CAAC/B,IAAD;AANX,KAArB;AAQD;;AAED,WAASrB,OAAT,CAAiBqB,IAAjB,EAAuB;AACrBwB,IAAAA,cAAc;;AACdnD,IAAAA,MAAM,CAACoD,aAAP,CAAqB;AACnB3B,MAAAA,IAAI,EAAEjC,YADa;AAEnBwE,MAAAA,IAAI,EAAErC,IAAI,CAACE,KAFQ;AAGnB4B,MAAAA,QAAQ,EAAEC,oBAAoB,CAAC/B,IAAD;AAHX,KAArB;AAKD;;AAED,WAASnB,GAAT,CAAamB,IAAb,EAAmB;AACjB,QAAIsC,KAAK,GAAGzF,GAAG,CAACyF,KAAJ,CAAUtC,IAAV,CAAZ;AACA,QAAIuC,IAAI,GAAGD,KAAK,CAACC,IAAN,IAAc,CAAzB;AACA,QAAIC,MAAM,GAAGF,KAAK,CAACE,MAAN,IAAgB,CAA7B;AACA,QAAIC,MAAM,GAAGH,KAAK,CAACG,MAAN,IAAgB,CAA7B;AACA,QAAIC,KAAJ,CALiB,CAOjB;AACA;;AACAzD,IAAAA,YAAY,CAACuB,IAAb,GAAoB,IAApB;AACAvB,IAAAA,YAAY,CAACpC,GAAb,GAAmB,CAAC,CAApB;AACAoC,IAAAA,YAAY,CAAC0D,UAAb,GAA0B,CAAC,CAA3B;AACA1D,IAAAA,YAAY,CAAC2D,WAAb,GAA2B,CAAC,CAA5B;AACA3D,IAAAA,YAAY,CAAC4D,QAAb,GAAwB,EAAxB;AACA5D,IAAAA,YAAY,CAAC6D,eAAb,GAA+B,KAA/B;AACA7D,IAAAA,YAAY,CAAC8D,gBAAb,GAAgC,KAAhC;AACA9D,IAAAA,YAAY,CAAC+D,aAAb,GAA6B,KAA7B,CAhBiB,CAkBjB;AACA;;AACA9D,IAAAA,UAAU,CAAC+D,KAAX,GAAmB,KAAnB;AACA/D,IAAAA,UAAU,CAACgE,YAAX,GAA0B,CAACV,MAAD,GAAU,CAApC,CArBiB,CAqBqB;;AACtCtD,IAAAA,UAAU,CAACiE,iBAAX,GAA+BV,MAA/B;AACAvD,IAAAA,UAAU,CAACuD,MAAX,GAAoB,CAApB;AACAvD,IAAAA,UAAU,CAACkE,GAAX,GAAiB,CAAjB;AACAlE,IAAAA,UAAU,CAACqD,IAAX,GAAkBA,IAAlB,CAzBiB,CA2BjB;AACA;;AACApD,IAAAA,eAAe,CAACkE,mBAAhB,GAAsC,IAAtC;AACAlE,IAAAA,eAAe,CAACmE,KAAhB,GAAwBvB,oBAAoB,CAAC/B,IAAD,CAA5C,CA9BiB,CAgCjB;AACA;;AACAhB,IAAAA,SAAS,CAACuE,KAAV,CAAgBvD,IAAI,CAACE,KAArB;;AACA7B,IAAAA,MAAM,CAACmF,eAAP,CAAuB,IAAvB,EAnCiB,CAqCjB;AACA;AACA;;;AACAd,IAAAA,KAAK,GAAG1D,SAAS,CAACyE,qBAAlB;;AAEA,QAAIf,KAAJ,EAAW;AACTA,MAAAA,KAAK,CAACZ,QAAN,CAAe4B,OAAf,GAAyBxE,UAAU,CAACqD,IAApC;AACAG,MAAAA,KAAK,CAACZ,QAAN,CAAe6B,MAAf,GAAwBzE,UAAU,CAACkE,GAAX,GAAiB,CAAzC;AACAV,MAAAA,KAAK,CAACZ,QAAN,CAAe8B,SAAf,GAA2B1E,UAAU,CAACuD,MAAX,GAAoB,CAA/C;;AACApE,MAAAA,MAAM,CAACoD,aAAP,CAAqBiB,KAArB;AACD;AACF;;AAED,WAASjD,MAAT,CAAgBO,IAAhB,EAAsB;AACpB,QAAI6D,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB/D,IAAlB,CAAZ;AAEAjB,IAAAA,QAAQ,GAAG,IAAX,CAHoB,CAKpB;AACA;;AACA,QAAIiB,IAAI,CAACD,QAAT,EAAmB;AACjB8D,MAAAA,KAAK,CAAC9D,QAAN,GAAiBxC,IAAI,CACnB;AAACuC,QAAAA,IAAI,EAAE,MAAP;AAAeC,QAAAA,QAAQ,EAAEC,IAAI,CAACD;AAA9B,OADmB,EAEnB5B,IAFmB,EAGnBC,OAHmB,CAAJ,CAIf2B,QAJF;AAKD,KAbmB,CAepB;AACA;AACA;;;AACApB,IAAAA,OAAO,CAAC;AAACuB,MAAAA,KAAK,EAAE;AAACT,QAAAA,MAAM,EAAEoE;AAAT;AAAR,KAAD,CAAP;AACD;;AAED,WAASrC,cAAT,GAA0B;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACAxC,IAAAA,SAAS,CAACgF,UAAV,GAAuB,EAAvB;AACAhF,IAAAA,SAAS,CAACiF,KAAV,GAAkBxG,SAAlB;AACAuB,IAAAA,SAAS,CAACkF,WAAV,GAAwB,EAAxB;AACAlF,IAAAA,SAAS,CAACmF,WAAV,GAAwB,CAAC,CAAzB;AACAnF,IAAAA,SAAS,CAACoF,QAAV,GAAqB,EAArB;AACApF,IAAAA,SAAS,CAACqF,gBAAV,GAA6B,EAA7B;AACArF,IAAAA,SAAS,CAACsF,qBAAV,GAAkC,CAAC,CAAnC;AACAtF,IAAAA,SAAS,CAACuF,MAAV,GAAmB,KAAnB;AACAvF,IAAAA,SAAS,CAACyE,qBAAV,GAAkC,IAAlC;AACAzE,IAAAA,SAAS,CAACwF,YAAV,GAAyB,IAAzB;AACAxF,IAAAA,SAAS,CAACyF,WAAV,GAAwB,IAAxB;AACD;AACF;;AAED,SAAS/C,QAAT,CAAkB1B,IAAlB,EAAwB;AACtB,MAAI8B,QAAQ,GAAGC,oBAAoB,CAAC/B,IAAD,CAAnC;AAEA8B,EAAAA,QAAQ,CAACJ,QAAT,GAAoBtE,KAAK,CAAC0E,QAAD,CAAzB;AAEA,SAAO;AACLhC,IAAAA,IAAI,EAAEnC,aADD;AAEL0C,IAAAA,OAAO,EAAEL,IAAI,CAACK,OAFT;AAGLqE,IAAAA,WAAW,EAAE,KAHR;AAILpE,IAAAA,KAAK,EAAEqE,UAAU,CAAC3E,IAAD,CAJZ;AAKL8B,IAAAA,QAAQ,EAAEA;AALL,GAAP;AAOD;;AAED,SAAS6C,UAAT,CAAoB3E,IAApB,EAA0B;AACxB,SAAOhD,QAAQ,CAAC;AACdqD,IAAAA,OAAO,EAAEL,IAAI,CAACK,OADA;AAEdP,IAAAA,IAAI,EAAE,SAFQ;AAGd8E,IAAAA,UAAU,EAAE5E,IAAI,CAAC4E;AAHH,GAAD,CAAR,CAIJtE,KAJH;AAKD;;AAED,SAASsB,MAAT,CAAgB5B,IAAhB,EAAsB;AACpB,MAAI8B,QAAQ,GAAGC,oBAAoB,CAAC/B,IAAD,CAAnC;AAEA8B,EAAAA,QAAQ,CAACF,MAAT,GAAkBxE,KAAK,CAAC0E,QAAD,CAAvB;AAEA,SAAO;AACLhC,IAAAA,IAAI,EAAElC,WADD;AAELyC,IAAAA,OAAO,EAAEL,IAAI,CAACK,OAFT;AAGLC,IAAAA,KAAK,EAAE,EAHF;AAILwB,IAAAA,QAAQ,EAAEA;AAJL,GAAP;AAMD;;AAED,SAAShD,OAAT,CAAiBkB,IAAjB,EAAuB;AACrB,QAAM,IAAI6E,KAAJ,CAAU,qBAAqB7E,IAAI,CAACF,IAA1B,GAAiC,QAA3C,CAAN;AACD;;AAED,SAASJ,YAAT,CAAsBM,IAAtB,EAA4B;AAC1B,MAAI8E,IAAI,GAAG9E,IAAI,CAACF,IAAL,KAAc,MAAd,GAAuBE,IAAI,CAACD,QAAL,CAAc,CAAd,CAAvB,GAA0CC,IAArD;AAEA,SAAO8E,IAAI,KAAKA,IAAI,CAAChF,IAAL,KAAc,SAAd,IAA2BgF,IAAI,CAACzE,OAAL,KAAiB,MAAjD,CAAX;AACD;;AAED,SAAS0B,oBAAT,CAA8B/B,IAA9B,EAAoC;AAClC,MAAIsC,KAAK,GAAGzF,GAAG,CAACyF,KAAJ,CAAUtC,IAAV,CAAZ;AACA,MAAI+E,GAAG,GAAGlI,GAAG,CAACkI,GAAJ,CAAQ/E,IAAR,CAAV;AAEA,SAAO;AACLgF,IAAAA,SAAS,EAAE1C,KAAK,CAACC,IADZ;AAEL0C,IAAAA,QAAQ,EAAE3C,KAAK,CAACE,MAFX;AAGL0C,IAAAA,WAAW,EAAE5C,KAAK,CAACG,MAHd;AAILiB,IAAAA,OAAO,EAAEqB,GAAG,CAACxC,IAJR;AAKLoB,IAAAA,MAAM,EAAEoB,GAAG,CAACvC,MALP;AAMLoB,IAAAA,SAAS,EAAEmB,GAAG,CAACtC;AANV,GAAP;AAQD","sourcesContent":["'use strict'\n\nvar Parser = require('parse5/lib/parser')\nvar pos = require('unist-util-position')\nvar visit = require('unist-util-visit')\nvar fromParse5 = require('hast-util-from-parse5')\nvar toParse5 = require('hast-util-to-parse5')\nvar voids = require('html-void-elements')\nvar ns = require('web-namespaces')\nvar zwitch = require('zwitch')\nvar xtend = require('xtend')\n\nmodule.exports = wrap\n\nvar inTemplateMode = 'IN_TEMPLATE_MODE'\nvar dataState = 'DATA_STATE'\nvar characterToken = 'CHARACTER_TOKEN'\nvar startTagToken = 'START_TAG_TOKEN'\nvar endTagToken = 'END_TAG_TOKEN'\nvar commentToken = 'COMMENT_TOKEN'\nvar doctypeToken = 'DOCTYPE_TOKEN'\n\nvar parseOptions = {sourceCodeLocationInfo: true, scriptingEnabled: false}\n\nfunction wrap(tree, file, options) {\n  var parser = new Parser(parseOptions)\n  var one = zwitch('type', {\n    handlers: {\n      root: root,\n      element: element,\n      text: text,\n      comment: comment,\n      doctype: doctype,\n      raw: raw\n    },\n    unknown: unknown\n  })\n  var stitches\n  var tokenizer\n  var preprocessor\n  var posTracker\n  var locationTracker\n  var result\n  var index\n\n  if (file && !('contents' in file)) {\n    options = file\n    file = undefined\n  }\n\n  if (options && options.passThrough) {\n    index = -1\n\n    while (++index < options.passThrough.length) {\n      one.handlers[options.passThrough[index]] = stitch\n    }\n  }\n\n  result = fromParse5(documentMode(tree) ? document() : fragment(), file)\n\n  if (stitches) {\n    visit(result, 'comment', mend)\n  }\n\n  // Unpack if possible and when not given a `root`.\n  if (tree.type !== 'root' && result.children.length === 1) {\n    return result.children[0]\n  }\n\n  return result\n\n  function mend(node, index, parent) {\n    if (node.value.stitch) {\n      parent.children[index] = node.value.stitch\n      return index\n    }\n  }\n\n  function fragment() {\n    var context = {\n      nodeName: 'template',\n      tagName: 'template',\n      attrs: [],\n      namespaceURI: ns.html,\n      childNodes: []\n    }\n    var mock = {\n      nodeName: 'documentmock',\n      tagName: 'documentmock',\n      attrs: [],\n      namespaceURI: ns.html,\n      childNodes: []\n    }\n    var doc = {nodeName: '#document-fragment', childNodes: []}\n\n    parser._bootstrap(mock, context)\n    parser._pushTmplInsertionMode(inTemplateMode)\n    parser._initTokenizerForFragmentParsing()\n    parser._insertFakeRootElement()\n    parser._resetInsertionMode()\n    parser._findFormInFragmentContext()\n\n    tokenizer = parser.tokenizer\n    preprocessor = tokenizer.preprocessor\n    locationTracker = tokenizer.__mixins[0]\n    posTracker = locationTracker.posTracker\n\n    one(tree)\n\n    parser._adoptNodes(mock.childNodes[0], doc)\n\n    return doc\n  }\n\n  function document() {\n    var doc = parser.treeAdapter.createDocument()\n\n    parser._bootstrap(doc, null)\n    tokenizer = parser.tokenizer\n    preprocessor = tokenizer.preprocessor\n    locationTracker = tokenizer.__mixins[0]\n    posTracker = locationTracker.posTracker\n\n    one(tree)\n\n    return doc\n  }\n\n  function all(nodes) {\n    var index = -1\n\n    /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n    if (nodes) {\n      while (++index < nodes.length) {\n        one(nodes[index])\n      }\n    }\n  }\n\n  function root(node) {\n    all(node.children)\n  }\n\n  function element(node) {\n    resetTokenizer()\n    parser._processToken(startTag(node), ns.html)\n\n    all(node.children)\n\n    if (voids.indexOf(node.tagName) < 0) {\n      resetTokenizer()\n      parser._processToken(endTag(node))\n    }\n  }\n\n  function text(node) {\n    resetTokenizer()\n    parser._processToken({\n      type: characterToken,\n      chars: node.value,\n      location: createParse5Location(node)\n    })\n  }\n\n  function doctype(node) {\n    var p5 = toParse5(node)\n    resetTokenizer()\n    parser._processToken({\n      type: doctypeToken,\n      name: p5.name,\n      forceQuirks: false,\n      publicId: p5.publicId,\n      systemId: p5.systemId,\n      location: createParse5Location(node)\n    })\n  }\n\n  function comment(node) {\n    resetTokenizer()\n    parser._processToken({\n      type: commentToken,\n      data: node.value,\n      location: createParse5Location(node)\n    })\n  }\n\n  function raw(node) {\n    var start = pos.start(node)\n    var line = start.line || 1\n    var column = start.column || 1\n    var offset = start.offset || 0\n    var token\n\n    // Reset preprocessor:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js>.\n    preprocessor.html = null\n    preprocessor.pos = -1\n    preprocessor.lastGapPos = -1\n    preprocessor.lastCharPos = -1\n    preprocessor.gapStack = []\n    preprocessor.skipNextNewLine = false\n    preprocessor.lastChunkWritten = false\n    preprocessor.endOfChunkHit = false\n\n    // Reset preprocessor mixin:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n    posTracker.isEol = false\n    posTracker.lineStartPos = -column + 1 // Looks weird, but ensures we get correct positional info.\n    posTracker.droppedBufferSize = offset\n    posTracker.offset = 0\n    posTracker.col = 1\n    posTracker.line = line\n\n    // Reset location tracker:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n    locationTracker.currentAttrLocation = null\n    locationTracker.ctLoc = createParse5Location(node)\n\n    // See the code for `parse` and `parseFragment`:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n    tokenizer.write(node.value)\n    parser._runParsingLoop(null)\n\n    // Process final characters if theyâ€™re still there after hibernating.\n    // Similar to:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n    token = tokenizer.currentCharacterToken\n\n    if (token) {\n      token.location.endLine = posTracker.line\n      token.location.endCol = posTracker.col + 1\n      token.location.endOffset = posTracker.offset + 1\n      parser._processToken(token)\n    }\n  }\n\n  function stitch(node) {\n    var clone = Object.assign({}, node)\n\n    stitches = true\n\n    // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n    // passed through node).\n    if (node.children) {\n      clone.children = wrap(\n        {type: 'root', children: node.children},\n        file,\n        options\n      ).children\n    }\n\n    // Hack: `value` is supposed to be a string, but as none of the tools\n    // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n    // through.\n    comment({value: {stitch: clone}})\n  }\n\n  function resetTokenizer() {\n    // Reset tokenizer:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n    // Especially putting it back in the `data` state is useful: some elements,\n    // like textareas and iframes, change the state.\n    // See GH-7.\n    // But also if broken HTML is in `raw`, and then a correct element is given.\n    // See GH-11.\n    tokenizer.tokenQueue = []\n    tokenizer.state = dataState\n    tokenizer.returnState = ''\n    tokenizer.charRefCode = -1\n    tokenizer.tempBuff = []\n    tokenizer.lastStartTagName = ''\n    tokenizer.consumedAfterSnapshot = -1\n    tokenizer.active = false\n    tokenizer.currentCharacterToken = null\n    tokenizer.currentToken = null\n    tokenizer.currentAttr = null\n  }\n}\n\nfunction startTag(node) {\n  var location = createParse5Location(node)\n\n  location.startTag = xtend(location)\n\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location: location\n  }\n}\n\nfunction attributes(node) {\n  return toParse5({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties\n  }).attrs\n}\n\nfunction endTag(node) {\n  var location = createParse5Location(node)\n\n  location.endTag = xtend(location)\n\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location: location\n  }\n}\n\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node')\n}\n\nfunction documentMode(node) {\n  var head = node.type === 'root' ? node.children[0] : node\n\n  return head && (head.type === 'doctype' || head.tagName === 'html')\n}\n\nfunction createParse5Location(node) {\n  var start = pos.start(node)\n  var end = pos.end(node)\n\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  }\n}\n"]},"metadata":{},"sourceType":"script"}